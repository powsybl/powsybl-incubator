model ampl_dataread_model.mod;
data ampl_data.dat;
model ampl_computed_data.mod;
model ampl_model.mod;
option solver knitroampl;
/*
display BUSES;
display PV_BUSES;
display PQ_BUSES;
display br_x;
display ss_country;
display BRANCHES;
display slack_bus;
display ld_p0;
display br_y;
display br_ksi;
*/
problem Initialize_voltage_plan: V, Phi, Q, Quadratic_Error, Active_power_balance, Null_phase_slack, Rective_power_balance_PQ, Rective_power_balance_PV, Reactive_power_inf, Reactive_power_sup, Voltage_limit_inf, Voltage_limit_sup;

solve Initialize_voltage_plan;
/*
display V;
display Phi;
display Active_power_balance;

for{i in BUSES: i != slack_bus} {
    display i;
    display sum {j in BRANCHES: br_bus1[1,j] == i} ( br_cstr[1,j] * V[i] * ( br_g1[1,j] * br_cstr[1,j] * V[i] + br_y[j] * br_cstr[1,j] * V[i] * sin(br_ksi[j]) - br_y[j] * 1 * V[br_bus2[1,j]] * sin(br_ksi[j] - 0 + 0 - Phi[i] + Phi[br_bus2[1,j]]) ) )
        + sum {j in BRANCHES: br_bus2[1,j] == i} ( 1 * V[i] * ( br_g2[1,j] * 1 * V[i] - br_y[j] * br_cstr[1,j] * V[br_bus1[1,j]] * sin(br_ksi[j] + 0 - 0 + Phi[br_bus1[1,j]] - Phi[i]) + br_y[j] * 1 * V[i] * sin(br_ksi[j]) ) );
    display sum {j in GENS: gen_bus[1,j] == i} gen_targetp[1,j] - sum {j in LOADS: ld_bus[1,j] == i} ld_p0[1,j];
    display sum {j in BRANCHES: br_bus1[1,j] == i} ( br_cstr[1,j] * V[i] * (- br_b1[1,j] * br_cstr[1,j] * V[i] + br_y[j] * br_cstr[1,j] * V[i] * cos(br_ksi[j]) - br_y[j] * 1 * V[br_bus2[1,j]] * cos(br_ksi[j] - 0 + 0 - Phi[i] + Phi[br_bus2[1,j]]) ) )
        + sum {j in BRANCHES: br_bus2[1,j] == i} ( 1 * V[i] * ( - br_b2[1,j] * 1 * V[i] - br_y[j] * br_cstr[1,j] * V[br_bus1[1,j]] * cos(br_ksi[j] + 0 - 0 + Phi[br_bus1[1,j]] - Phi[i]) + br_y[j] * 1 * V[i] * cos(br_ksi[j]) ) );
    display sum {j in GENS: gen_bus[1,j] == i} gen_targetq[1,j] - sum {j in LOADS: ld_bus[1,j] == i} ld_q0[1,j];
}
printf "slack node (i=1) \n";
display sum {j in BRANCHES: br_bus1[1,j] == 1} ( br_cstr[1,j] * V[1] * ( br_g1[1,j] * br_cstr[1,j] * V[1] + br_y[j] * br_cstr[1,j] * V[1] * sin(br_ksi[j]) - br_y[j] * 1 * V[br_bus2[1,j]] * sin(br_ksi[j] - 0 + 0 - Phi[1] + Phi[br_bus2[1,j]]) ) )
    + sum {j in BRANCHES: br_bus2[1,j] == 1} ( 1 * V[1] * ( br_g2[1,j] * 1 * V[1] - br_y[j] * br_cstr[1,j] * V[br_bus1[1,j]] * sin(br_ksi[j] + 0 - 0 + Phi[br_bus1[1,j]] - Phi[1]) + br_y[j] * 1 * V[1] * sin(br_ksi[j]) ) );
display Q[1];
*/