###############################################################################
#
# Copyright (c) 2022 2023, RTE (http://www.rte-france.com)
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
###############################################################################

###############################################################################
# Reactive OPF
# Author:  Jean Maeght 2022 2023
###############################################################################



###############################################################################
#
# Writing results for shunts
#
###############################################################################
if final_status == "OK" then {

  let fileOut := "reactiveopf_results_shunts.csv";
  printf "#variant;num;bus;b(pu);Q(Mvar);section;\n" > (fileOut);
  # Shunts which were already connected, with variable value
  printf{(s,n) in SHUNT_VAR: (1,s,n) in SHUNT} "%i;%i;%i;%.3f;%.3f;%i;\n",
    1,s,n,
    shunt_var[s,n],
    base100MVA * shunt_var[s,n] * V[n]^2,
    0 #shunt_sections_count[1,s,n] # don't know what this is, so write 0 
    > (fileOut);
  # Shunts which were not connected, and which have been reconnected by reactiveopf, with variable value
  printf {(s,n) in SHUNT_VAR: (1,s,-1) in SHUNT} "%i;%i;%i;%.3f;%.3f;%i;\n",
    1,s,n,shunt_var[s,n],base100MVA * shunt_var[s,n] * V[n]^2,
    0 #shunt_sections_count[1,s,-1] # don't know what this is, so write 0 
    > (fileOut);
  close (fileOut);

}



###############################################################################
#
# Writing results for SVC
#
###############################################################################
if final_status == "OK" then {

let fileOut := "reactiveopf_results_static_var_compensators.csv";
printf "#variant;num;bus;vRegul;V(pu);Q(Mvar);\n" > (fileOut);
printf{(s,n) in SVCON} "%i;%i;%i;%Q;%.3f;%.3f;\n",
  1,s,n,
  svc_vregul[1,s,n],
  V[n],
  base100MVA * svc_qvar[s,n] * V[n]^2
  > (fileOut);
close (fileOut);

}



###############################################################################
#
# Writing results for units
#
###############################################################################
if final_status == "OK" then {

let fileOut := "reactiveopf_results_generators.csv";
printf "#variant;num;bus;vRegul;V(pu);targetP(MW);targetQ(Mvar);P(MW);Q(MW);\n" > (fileOut);
printf{(g,n) in UNITON} "%i;%i;%i;%Q;%.3f;%.3f;%.3f;%.3f;%.3f;\n",
  1,g,n,
  unit_vregul[1,g,n],
  V[n],
  unit_Pc[1,g,n],
  if (g,n) in UNIT_FIXQ then unit_Qc[1,g,n] else Q[g,n],
  P[g,n],
  if (g,n) in UNIT_FIXQ then unit_Qc[1,g,n] else Q[g,n]
  > (fileOut);
close (fileOut);

}



###############################################################################
#
# Writing results for VSC converters
#
###############################################################################
if final_status == "OK" then {

let fileOut := "reactiveopf_results_vsc_converter_stations.csv";
printf "#variant;num;bus;vRegul;targetV(pu);targetQ(Mvar);P(MW);Q(Mvar);\n" > (fileOut);
printf{(v,n) in VSCCONVON} "%i;%i;%i;%Q;%.3f;%.3f;%.3f;%.3f;\n",
  1,v,n,
  vscconv_vregul[1,v,n],
  V[n],
  vscconv_qvar[v,n],
  vscconv_P0[1,v,n],
  vscconv_qvar[v,n]
  > (fileOut);
close (fileOut);

}



###############################################################################
#
# Writing results for transformers
#
###############################################################################
if final_status == "OK" then {

let fileOut := "reactiveopf_results_rtc.csv";
printf "#variant;num;tap;\n" > (fileOut);
for{(qq,m,n) in BRANCHCC_REGL_VAR} {
  let temp1 := 
    min{(1,regl_table[1,branch_ptrRegl[1,qq,m,n]],tap) in TAPS}
      abs(branch_Ror_var[qq,m,n]-tap_ratio[1,regl_table[1,branch_ptrRegl[1,qq,m,n]],tap]);
  let temp2 :=
    min{(1,regl_table[1,branch_ptrRegl[1,qq,m,n]],tap) in TAPS:
      abs(branch_Ror_var[qq,m,n]-tap_ratio[1,regl_table[1,branch_ptrRegl[1,qq,m,n]],tap])<=1.00001*temp1}tap;
  if 0 and card(BRANCHCC_REGL_VAR)<=10 then
  printf "REGL=%Q ptrRegl=%i regl_table=%i Ror_var=%f min=%f tap=%i tap_ratio=%f err=%f\n",
    branch_id[1,qq,m,n],branch_ptrRegl[1,qq,m,n],regl_table[1,branch_ptrRegl[1,qq,m,n]],
    branch_Ror_var[qq,m,n],temp1,
    temp2,
    tap_ratio[1,regl_table[1,branch_ptrRegl[1,qq,m,n]],temp2],
    abs(branch_Ror_var[qq,m,n]-tap_ratio[1,regl_table[1,branch_ptrRegl[1,qq,m,n]],temp2])
    ;
  printf "%i;%i;%i;\n",
    1,qq,temp2
    > (fileOut);
}
close (fileOut);

}

# Useful during tests to create list of transformers
if 0 then
printf {(qq,m,n) in BRANCHCC_REGL: 
  substation_Vnomi[1,bus_substation[1,m]]>21 and substation_Vnomi[1,bus_substation[1,m]]<300 and
  substation_Vnomi[1,bus_substation[1,n]]>21 and substation_Vnomi[1,bus_substation[1,n]]<300 and
  (substation_Vnomi[1,bus_substation[1,m]]>120 or substation_Vnomi[1,bus_substation[1,n]]>120) and
  (substation_Vnomi[1,bus_substation[1,m]]<120 or substation_Vnomi[1,bus_substation[1,n]]<120)
} "1 %i %i %i %Q\n",qq,m,n,branch_id[1,qq,m,n] > param_transformers.txtt;



###############################################################################
#
# Writing results for reactive slacks
#
###############################################################################
if final_status == "OK" 
and card({n in BUSCC_SLACK: slack1_balance_Q[n]>Pnull or slack2_balance_Q[n]>Pnull}) > 0
then {

let fileOut := "reactiveopf_results_reactive_slacks.csv";
printf "#variant;bus;slack_condensator(Mvar);slack_self(Mvar);id;substation;\n" > (fileOut);
printf{n in BUSCC_SLACK: slack1_balance_Q[n]>Pnull or slack2_balance_Q[n]>Pnull}
  "%i;%i;%.2f;%.2f;%Q;%Q;\n",
  1,n,
  if slack1_balance_Q[n]>Pnull then slack1_balance_Q[n] else 0, 
  if slack2_balance_Q[n]>Pnull then slack2_balance_Q[n] else 0,
  bus_id[1,n],
  substation_id[1,bus_substation[1,n]]
  > (fileOut);
close (fileOut);

}



###############################################################################
#
# Writing results for LCC converters
#
###############################################################################
# No results to be written since they are used with fixed P and Q red in ampl_network_lcc_converter_stations.txt



###############################################################################
#
# Writing indicator file
#
###############################################################################
let fileOut := "reactiveopf_results_indic.txt";

printf "%s %s\n","final_status",final_status > (fileOut);
printf "%s %s\n","dcopf_status",dcopf_status > (fileOut);

printf "\n" > (fileOut);
printf "%s %i\n","last_solve_result_num",solve_result_num > (fileOut);
printf "%s %i\n","nb_iter_last",nb_iter_last > (fileOut);
printf "%s %i\n","nb_iter_total",nb_iter_total > (fileOut);
printf "%s %f\n","_ampl_elapsed_time",_ampl_elapsed_time > (fileOut);
printf "%s %f\n","_total_solve_time",_total_solve_time > (fileOut);
printf "%s %i\n","total_time",_total_solve_time+_ampl_elapsed_time > (fileOut);

printf "\n" > (fileOut);
printf "%s %s\n","operatingSystem",operatingSystem > (fileOut);
if length($OS) > 0 then {
  printf "%s %Q\n","OS",$OS > (fileOut); # Windows
  printf "%s %Q\n","COMPUTERNAME",$COMPUTERNAME > (fileOut);
}
if length($SHELL) > 0 then {
  printf "%s %Q\n","SHELL",$SHELL > (fileOut); # Linux
  printf "%s %Q\n","HOSTNAME",$HOSTNAME > (fileOut);
}
printf "%s %Q\n","directory",_cd > (fileOut);

printf "\n" > (fileOut);
printf "%s %i\n","objective_choice",objective_choice > (fileOut);
printf "%s %f\n","ratio_voltage_target",ratio_voltage_target > (fileOut);
printf "%s %f\n","Pnull",Pnull > (fileOut);
printf "%s %f\n","Znull",Znull > (fileOut);
printf "%s %f\n","epsilon_nominal_voltage",epsilon_nominal_voltage > (fileOut);
printf "%s %f\n","epsilon_min_voltage",epsilon_min_voltage > (fileOut);
printf "%s %f\n","ignore_voltage_bounds",ignore_voltage_bounds > (fileOut);
printf "%s %f\n","PQmax",PQmax > (fileOut);
printf "%s %f\n","defaultPmax",defaultPmax > (fileOut);
printf "%s %f\n","defaultPmin",defaultPmin > (fileOut);
printf "%s %f\n","defaultQmaxPmaxRatio",defaultQmaxPmaxRatio > (fileOut);
printf "%s %f\n","defaultQmin",defaultQmin > (fileOut);
printf "%s %f\n","defaultQmax",defaultQmax > (fileOut);
printf "%s %f\n","minimalQPrange",minimalQPrange > (fileOut);

printf "\n" > (fileOut);
printf "%s %i\n","nb_substations",card(SUBSTATIONS) > (fileOut);
printf "%s %i\n","nb_bus_in_data_file",card(BUS) > (fileOut);
printf "%s %i\n","nb_bus_in_ACDC_CC",card(BUS2) > (fileOut);
printf "%s %i\n","nb_bus_in_AC_CC",card(BUSCC) > (fileOut);
printf "%s %i\n","nb_bus_in_ACDC_but_out_AC_CC",card(BUS2 diff BUSCC) > (fileOut);
printf "%s %i\n","nb_bus_with_voltage_value",card(BUSVV) > (fileOut);
printf "%s %i\n","nb_bus_with_reactive_slacks",card(BUSCC_SLACK) > (fileOut);
printf "%s %i\n","nb_bus_without_reactive_slacks",card(BUSCC diff BUSCC_SLACK) > (fileOut);
printf "%s %i\n","nb_branch_in_data_file",card(BRANCH) > (fileOut);
printf "%s %i\n","nb_branch_in_AC_CC",card(BRANCHCC) > (fileOut);
printf "%s %i\n","nb_branch_with_nonsmall_impedance",card(BRANCHCC diff BRANCHZNULL) > (fileOut);
printf "%s %i\n","nb_branch_with_zero_or_small_impedance",card(BRANCHZNULL) > (fileOut);
printf "%s %i\n","nb_unit_in_data_file",card(UNIT) > (fileOut);
printf "%s %i\n","nb_unit_in_AC_CC",card(UNITCC) > (fileOut);
printf "%s %i\n","nb_unit_up_and_running",card(UNITON) > (fileOut);
printf "%s %i\n","nb_unit_with_variable_reactive_power",card(UNITON diff UNIT_FIXQ) > (fileOut);
printf "%s %i\n","nb_unit_with_fixed_reactive_power",card(UNIT_FIXQ) > (fileOut);
printf "%s %i\n","nb_load_in_data_file",card(LOAD) > (fileOut);
printf "%s %i\n","nb_load_in_AC_CC",card(LOADCC) > (fileOut);
printf "%s %i\n","nb_shunt_in_data_file",card(SHUNT) > (fileOut);
printf "%s %i\n","nb_shunt_connectable_or_in_AC_CC",card(SHUNTCC) > (fileOut);
printf "%s %i\n","nb_shunt_with_fixed_value",card(SHUNT_FIX) > (fileOut);
printf "%s %i\n","nb_shunt_with_variable_value",card(SHUNT_VAR) > (fileOut);
printf "%s %i\n","nb_transformers_with_variable_ratio",card(BRANCHCC_REGL_VAR) > (fileOut);
printf "%s %i\n","nb_transformers_with_fixed_ratio",card(BRANCHCC_REGL_FIX) > (fileOut);
printf "%s %i\n","nb_svc_in_data_file",card(SVC) > (fileOut);
printf "%s %i\n","nb_svc_in_AC_CC",card(SVCCC) > (fileOut);
printf "%s %i\n","nb_svc_up_and_operating",card(SVCON) > (fileOut);
printf "%s %i\n","nb_vsc_converter_in_data_file",card(VSCCONV) > (fileOut);
printf "%s %i\n","nb_vsc_converter_up_and_running",card(VSCCONVON) > (fileOut);
printf "%s %i\n","nb_lcc_converter_in_data_file",card(LCCCONV) > (fileOut);
printf "%s %i\n","nb_lcc_converter_up_and_running",card(LCCCONVON) > (fileOut);

printf "\n" > (fileOut);
printf "max_teta_dc %.2f\n",max({n in BUSCC} teta_dc[n]) > (fileOut);
printf "max_teta_ac %.2f\n",max({n in BUSCC} teta[n]) > (fileOut);
printf "teta_max %.2f\n",teta_max > (fileOut);
printf "min_teta_dc %.2f\n",min({n in BUSCC} teta_dc[n]) > (fileOut);
printf "min_teta_ac %.2f\n",min({n in BUSCC} teta[n]) > (fileOut);
printf "teta_min %.2f\n",teta_min > (fileOut);
printf "max_delta_teta_dc %2f\n",max({(qq,m,n) in BRANCHCC} (teta_dc[m]-teta_dc[n])) > (fileOut);
printf "max_delta_teta_ac %2f\n",max({(qq,m,n) in BRANCHCC} (teta[m]-teta[n])) > (fileOut);
printf "min_delta_teta_dc %2f\n",min({(qq,m,n) in BRANCHCC} (teta_dc[m]-teta_dc[n])) > (fileOut);
printf "min_delta_teta_ac %2f\n",min({(qq,m,n) in BRANCHCC} (teta[m]-teta[n])) > (fileOut);

printf "\n" > (fileOut);
printf "%s %i\n","nb_reactive_slacks",card({n in BUSCC_SLACK: slack1_balance_Q[n]>Pnull or slack2_balance_Q[n]>Pnull}) > (fileOut);
printf "%s %i\n","nb_slacks_condensator",card({n in BUSCC_SLACK: slack1_balance_Q[n]>Pnull}) > (fileOut);
printf "%s %.1f\n","sum_slacks_condensator",sum{n in BUSCC_SLACK} slack1_balance_Q[n] > (fileOut);
printf "%s %i\n","nb_slacks_self",card({n in BUSCC_SLACK: slack2_balance_Q[n]>Pnull}) > (fileOut);
printf "%s %.1f\n","sum_slacks_self",sum{n in BUSCC_SLACK} slack2_balance_Q[n] > (fileOut);

# All messages added in messages container
if card(messagesInfo) > 0 then {
  let temp1:=1;
  for { message in messagesInfo } {
    printf "messageInfo%i %Q\n",temp1,message > (fileOut);
    let temp1:=temp1+1;
  }
}
