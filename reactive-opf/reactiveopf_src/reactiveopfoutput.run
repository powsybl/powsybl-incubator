###############################################################################
#
# Copyright (c) 2022, RTE (http://www.rte-france.com)
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
###############################################################################

###############################################################################
# Reactive OPF
# Author :  Jean Maeght 2022 2023
###############################################################################



###############################################################################
#
# Writing results for shunts
#
###############################################################################
if final_status == "OK" then {

  let fileOut := "reactiveopf_results_shunts.csv";
  printf "#variant;num;bus;b(pu);Q(Mvar);section;\n" > (fileOut);
  # Shunts which were already connected, with variable value
  printf{(s,n) in SHUNT_VAR: (1,s,n) in SHUNT} "%i;%i;%i;%.3f;%.3f;%i;\n",
    1,s,n,
    shunt_var[s,n],
    base100MVA * shunt_var[s,n] * V[n]^2,
    shunt_sections_count[1,s,n] 
    > (fileOut);
  # Shunts which were not connected, and which have been reconnected by reactiveopf, with variable value
  printf {(s,n) in SHUNT_VAR: (1,s,-1) in SHUNT} "%i;%i;%i;%.3f;%.3f;%i;\n",
    1,s,n,shunt_var[s,n],base100MVA * shunt_var[s,n] * V[n]^2,
    shunt_sections_count[1,s,-1] 
    > (fileOut);
  close (fileOut);

}



###############################################################################
#
# Writing results for SVC
#
###############################################################################
if final_status == "OK" then {

let fileOut := "reactiveopf_results_static_var_compensators.csv";
printf "#variant;num;bus;vRegul;V(pu);Q(Mvar);\n" > (fileOut);
printf{(s,n) in SVCON} "%i;%i;%i;%Q;%.3f;%.3f;\n",
  1,s,n,
  svc_vregul[1,s,n],
  V[n],
  base100MVA * svc_qvar[s,n] * V[n]^2
  > (fileOut);
close (fileOut);

}



###############################################################################
#
# Writing results for units
#
###############################################################################
if final_status == "OK" then {

let fileOut := "reactiveopf_results_generators.csv";
printf "#variant;num;bus;vRegul;V(pu);targetP(MW);targetQ(Mvar);P(MW);Q(MW);\n" > (fileOut);
printf{(g,n) in UNITON} "%i;%i;%i;%Q;%.3f;%.3f;%.3f;%.3f;%.3f;\n",
  1,g,n,
  unit_vregul[1,g,n],
  V[n],
  unit_Pc[1,g,n],
  if (g,n) in UNIT_FIXQ then unit_Qc[1,g,n] else Q[g,n],
  P[g,n],
  Q[g,n]
  > (fileOut);
close (fileOut);

}



###############################################################################
#
# Writing results for VSC converters
#
###############################################################################
if final_status == "OK" then {

let fileOut := "reactiveopf_results_vsc_converter_station.csv";
printf "#variant;num;bus;vRegul;targetV(pu);targetQ(Mvar);P(MW);Q(Mvar);\n" > (fileOut);
printf{(v,n) in VSCCONVON} "%i;%i;%i;%Q;%.3f;%.3f;%.3f;%.3f;\n",
  1,v,n,
  vscconv_vregul[1,v,n],
  V[n],
  vscconv_qvar[v,n],
  vscconv_P0[1,v,n],
  vscconv_qvar[v,n]
  > (fileOut);
close (fileOut);

}



###############################################################################
#
# Writing results for LCC converters
#
###############################################################################
# No results to be written since they are used with fixed P and Q red in ampl_network_lcc_converter_stations.txt



###############################################################################
#
# Writing indicator file
#
###############################################################################
let fileOut := "reactiveopf_results_indic.txt";

printf "%s %s\n","final_status",final_status > (fileOut);
printf "%s %s\n","dcopf_status",dcopf_status > (fileOut);

printf "\n" > (fileOut);
printf "%s %i\n","last_solve_result_num",solve_result_num > (fileOut);
printf "%s %i\n","nb_iter_last",nb_iter_last > (fileOut);
printf "%s %i\n","nb_iter_total",nb_iter_total > (fileOut);
printf "%s %f\n","_ampl_elapsed_time",_ampl_elapsed_time > (fileOut);
printf "%s %f\n","_total_solve_time",_total_solve_time > (fileOut);

printf "\n" > (fileOut);
printf "%s %s\n","operatingSystem",operatingSystem > (fileOut);
if length($OS) > 0 then {
  printf "%s %Q\n","OS",$OS > (fileOut); # Windows
  printf "%s %Q\n","COMPUTERNAME",$COMPUTERNAME > (fileOut);
}
if length($SHELL) > 0 then {
  printf "%s %Q\n","SHELL",$SHELL > (fileOut); # Linux
  printf "%s %Q\n","HOSTNAME",$HOSTNAME > (fileOut);
}

printf "\n" > (fileOut);
printf "%s %i\n","nb_substations",card(SUBSTATIONS) > (fileOut);
printf "%s %i\n","nb_bus_in_data_file",card(BUS) > (fileOut);
printf "%s %i\n","nb_bus_in_ACDC_CC",card(BUS2) > (fileOut);
printf "%s %i\n","nb_bus_in_AC_CC",card(BUSCC) > (fileOut);
printf "%s %i\n","nb_bus_in_ACDC_but_out_AC_CC",card(BUS2 diff BUSCC) > (fileOut);
printf "%s %i\n","nb_bus_with_voltage_value",card(BUSVV) > (fileOut);
printf "%s %i\n","nb_bus_with_reactive_slacks",card(BUSCC_SLACK) > (fileOut);
printf "%s %i\n","nb_bus_without_reactive_slacks",card(BUSCC diff BUSCC_SLACK) > (fileOut);
printf "%s %i\n","nb_branch_in_data_file",card(BRANCH) > (fileOut);
printf "%s %i\n","nb_branch_in_AC_CC",card(BRANCHCC) > (fileOut);
printf "%s %i\n","nb_branch_with_nonsmall_impedance",card(BRANCHCC diff BRANCHZNULL) > (fileOut);
printf "%s %i\n","nb_branch_with_zero_or_small_impedance",card(BRANCHZNULL) > (fileOut);
printf "%s %i\n","nb_unit_in_data_file",card(UNIT) > (fileOut);
printf "%s %i\n","nb_unit_in_AC_CC",card(UNITCC) > (fileOut);
printf "%s %i\n","nb_unit_up_and_running",card(UNITON) > (fileOut);
printf "%s %i\n","nb_unit_with_variable_reactive_power",card(UNITON diff UNIT_FIXQ) > (fileOut);
printf "%s %i\n","nb_unit_with_fixed_reactive_power",card(UNIT_FIXQ) > (fileOut);
printf "%s %i\n","nb_load_in_data_file",card(LOAD) > (fileOut);
printf "%s %i\n","nb_load_in_AC_CC",card(LOADCC) > (fileOut);
printf "%s %i\n","nb_shunt_in_data_file",card(SHUNT) > (fileOut);
printf "%s %i\n","nb_shunt_connectable_or_in_AC_CC",card(SHUNTCC) > (fileOut);
printf "%s %i\n","nb_shunt_with_fixed_value",card(SHUNT_FIX) > (fileOut);
printf "%s %i\n","nb_shunt_with_variable_value",card(SHUNT_VAR) > (fileOut);
printf "%s %i\n","nb_svc_in_data_file",card(SVC) > (fileOut);
printf "%s %i\n","nb_svc_in_AC_CC",card(SVCCC) > (fileOut);
printf "%s %i\n","nb_svc_up_and_operating",card(SVCON) > (fileOut);
printf "%s %i\n","nb_vsc_converter_in_data_file",card(VSCCONV) > (fileOut);
printf "%s %i\n","nb_vsc_converter_up_and_running",card(VSCCONVON) > (fileOut);
printf "%s %i\n","nb_lcc_converter_in_data_file",card(LCCCONV) > (fileOut);
printf "%s %i\n","nb_lcc_converter_up_and_running",card(LCCCONVON) > (fileOut);



printf "\n" > (fileOut);
printf "max_teta_dc %.2f\n",max({n in BUSCC} teta_dc[n]) > (fileOut);
printf "max_teta_ac %.2f\n",max({n in BUSCC} teta[n]) > (fileOut);
printf "teta_max %.2f\n",teta_max > (fileOut);
printf "min_teta_dc %.2f\n",min({n in BUSCC} teta_dc[n]) > (fileOut);
printf "min_teta_ac %.2f\n",min({n in BUSCC} teta[n]) > (fileOut);
printf "teta_min %.2f\n",teta_min > (fileOut);
printf "max_delta_teta_dc %2f\n",max({(qq,m,n) in BRANCHCC} (teta_dc[m]-teta_dc[n])) > (fileOut);
printf "max_delta_teta_ac %2f\n",max({(qq,m,n) in BRANCHCC} (teta[m]-teta[n])) > (fileOut);
printf "min_delta_teta_dc %2f\n",min({(qq,m,n) in BRANCHCC} (teta_dc[m]-teta_dc[n])) > (fileOut);
printf "min_delta_teta_ac %2f\n",min({(qq,m,n) in BRANCHCC} (teta[m]-teta[n])) > (fileOut);





# All messages added in messages container
if card(messagesInfo) > 0 then {
  let temp1:=1;
  for { message in messagesInfo } {
    printf "messageInfo%i %Q\n",temp1,message > (fileOut);
    let temp1:=temp1+1;
  }
}
